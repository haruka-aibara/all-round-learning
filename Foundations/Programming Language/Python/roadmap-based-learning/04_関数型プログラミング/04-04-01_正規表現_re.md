# Python 正規表現 (re) モジュールの使い方

## 概要
正規表現はテキストパターンを検索・マッチングするための強力なツールであり、データ検証やテキスト処理に不可欠です。

## 理論的説明
正規表現はテキストを検索、照合するための特殊な文字列パターンで、特定の規則に従って記述します。

## 実践的コード例と解説

### 基本的なインポート

以下のコードを入力して実行してみましょう：

```python
import re
```

これでPythonの正規表現モジュール `re` をインポートしました。

### 基本的なマッチング関数

#### match関数 - 文字列の先頭からマッチング

以下のコードを入力して実行してみましょう：

```python
# 文字列の先頭から「a」と「c」の間に任意の1文字があるパターンを検索
m = re.match("a.c", "abc")
print(m)  # マッチオブジェクトが返される
print(m.group())  # マッチした文字列を取得
```

実行結果：
```
<re.Match object; span=(0, 3), match='abc'>
abc
```

解説：
- `match()` 関数は文字列の先頭からパターンがマッチするか確認します
- `.` は任意の1文字にマッチする特殊文字です
- `group()` メソッドでマッチした部分の文字列を取得できます

#### search関数 - 文字列内のどこでもマッチング

以下のコードを入力して実行してみましょう：

```python
# 文字列内のどこかに「a」と「c」の間に任意の1文字があるパターンを検索
m = re.search("a.c", "test abc test abc")
print(m)  # 最初にマッチした箇所の情報を返す
print(m.span())  # マッチした位置の範囲(開始と終了のインデックス)を返す
print(m.group())  # マッチした文字列を取得
```

実行結果：
```
<re.Match object; span=(5, 8), match='abc'>
(5, 8)
abc
```

解説：
- `search()` 関数は文字列内のどこでもパターンを探します
- `span()` メソッドはマッチした部分の開始位置と終了位置を返します
- この例では文字列の5番目から8番目の位置でマッチしました

#### findall関数 - すべてのマッチを見つける

以下のコードを入力して実行してみましょう：

```python
# 文字列内のすべての「a」と「c」の間に任意の1文字があるパターンを検索
m = re.findall("a.c", "test abc test abc")
print(m)  # マッチした文字列のリストを返す
```

実行結果：
```
['abc', 'abc']
```

解説：
- `findall()` 関数は文字列内のすべてのマッチングを検索し、リストで返します
- この例では "abc" が2回見つかりました

#### finditer関数 - イテレータとしてマッチを返す

以下のコードを入力して実行してみましょう：

```python
# 文字列内のすべてのマッチをイテレータとして取得
m = re.finditer("a.c", "test abc test abc")
print([match.group() for match in m])  # マッチオブジェクトのイテレータからマッチした文字列のリストを作成
```

実行結果：
```
['abc', 'abc']
```

解説：
- `finditer()` 関数はマッチオブジェクトのイテレータを返します
- 各マッチオブジェクトから `group()` メソッドでマッチした文字列を取得できます

### 量指定子

#### ?（0回または1回）

以下のコードを入力して実行してみましょう：

```python
# 「a」の後に「b」が0回または1回出現するパターン
m = re.match("ab?", "abc")
print(m)
print(m.group())
```

実行結果：
```
<re.Match object; span=(0, 2), match='ab'>
ab
```

解説：
- `?` は直前の文字が0回または1回出現することを示します
- この例では "ab" がマッチしました

#### *（0回以上）

以下のコードを入力して実行してみましょう：

```python
# 「a」の後に「b」が0回以上出現するパターン
m = re.match("ab*", "abbbbb")
print(m)
print(m.group())
```

実行結果：
```
<re.Match object; span=(0, 6), match='abbbbb'>
abbbbb
```

解説：
- `*` は直前の文字が0回以上繰り返されることを示します
- この例では "abbbbb" がマッチしました（「b」が5回出現）

#### +（1回以上）

以下のコードを入力して実行してみましょう：

```python
# 「a」の後に「b」が1回以上出現するパターン
m = re.match("ab+", "abbbbb")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 6), match='abbbbb'>
```

解説：
- `+` は直前の文字が1回以上繰り返されることを示します
- この例では "abbbbb" がマッチしました（「b」が5回出現）

#### {n}（ちょうどn回）

以下のコードを入力して実行してみましょう：

```python
# 「a」がちょうど3回出現するパターン
m = re.match("a{3}", "aaabbbb")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 3), match='aaa'>
```

解説：
- `{n}` は直前の文字がちょうどn回繰り返されることを示します
- この例では "aaa" がマッチしました（「a」が3回出現）

#### {n,m}（n回以上m回以下）

以下のコードを入力して実行してみましょう：

```python
# 「a」が2回以上4回以下出現するパターン
m = re.match("a{2,4}", "aaaabbbb")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 4), match='aaaa'>
```

解説：
- `{n,m}` は直前の文字がn回以上m回以下繰り返されることを示します
- この例では "aaaa" がマッチしました（「a」が4回出現）

### 文字クラス

#### [a-c] - 範囲指定

以下のコードを入力して実行してみましょう：

```python
# a, b, cのいずれかの文字にマッチするパターン
m = re.match("[a-c]", "x")
print(m)  # xはa-cの範囲外なのでマッチしない

m = re.match("[a-c]", "a")
print(m)  # aはa-cの範囲内なのでマッチする
```

実行結果：
```
None
<re.Match object; span=(0, 1), match='a'>
```

解説：
- `[a-c]` は a, b, c のいずれかの文字にマッチします
- 最初の例では "x" はこの範囲に含まれないため `None` が返されました
- 2番目の例では "a" は範囲内のためマッチしました

#### [a-zA-Z] - 英字

以下のコードを入力して実行してみましょう：

```python
# 任意の英字1文字にマッチするパターン
m = re.match("[a-zA-Z]", "A")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='A'>
```

解説：
- `[a-zA-Z]` は大文字小文字の英字1文字にマッチします

#### [a-zA-Z0-9] - 英数字

以下のコードを入力して実行してみましょう：

```python
# 任意の英数字1文字にマッチするパターン
m = re.match("[a-zA-Z0-9]", "1")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='1'>
```

解説：
- `[a-zA-Z0-9]` は英字と数字のいずれか1文字にマッチします

#### [a-zA-Z0-9_] - 英数字とアンダースコア

以下のコードを入力して実行してみましょう：

```python
# 英数字またはアンダースコア1文字にマッチするパターン
m = re.match("[a-zA-Z0-9_]", "_")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='_'>
```

解説：
- `[a-zA-Z0-9_]` は英字、数字、アンダースコアのいずれか1文字にマッチします

### 特殊文字クラス

#### \w - 単語構成文字

以下のコードを入力して実行してみましょう：

```python
# 単語を構成する文字（英数字またはアンダースコア）にマッチするパターン
m = re.match(r"\w", "a")
print(m)

m = re.match(r"\w", "@")  # @は単語構成文字ではない
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='a'>
None
```

解説：
- `\w` は単語を構成する文字（[a-zA-Z0-9_]と同じ）にマッチします
- `r` プレフィックスは raw 文字列を示し、バックスラッシュを特別扱いしません
- 2番目の例では "@" は単語構成文字ではないため `None` が返されました

#### \W - 単語構成文字でない文字

以下のコードを入力して実行してみましょう：

```python
# 単語構成文字でない文字にマッチするパターン
m = re.match(r"\W", "@")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='@'>
```

解説：
- `\W` は単語構成文字以外の文字にマッチします（`\w` の逆）

#### [^a-zA-Z0-9_] - 否定文字クラス

以下のコードを入力して実行してみましょう：

```python
# 英数字とアンダースコア以外の文字にマッチするパターン
m = re.match("[^a-zA-Z0-9_]", "a")  # aは英字なのでマッチしない
print(m)
```

実行結果：
```
None
```

解説：
- `[^...]` は角括弧内に指定した文字以外の任意の文字にマッチします
- この例では "a" は英字であるためマッチしませんでした

#### \d - 数字

以下のコードを入力して実行してみましょう：

```python
# 任意の数字1文字にマッチするパターン
m = re.match(r"\d", "1")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='1'>
```

解説：
- `\d` は任意の数字（0-9）にマッチします

#### \D - 数字でない文字

以下のコードを入力して実行してみましょう：

```python
# 数字以外の文字にマッチするパターン
m = re.match(r"\D", "a")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='a'>
```

解説：
- `\D` は数字以外の任意の文字にマッチします（`\d` の逆）

### 選択と繰り返し

#### | - 選択（OR）

以下のコードを入力して実行してみましょう：

```python
# 「a」または「b」にマッチするパターン
m = re.match("a|b", "a")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='a'>
```

解説：
- `|` は「または」の意味を持ち、左右のパターンのいずれかにマッチします

#### () - グループ化と繰り返し

以下のコードを入力して実行してみましょう：

```python
# 「abc」が1回以上繰り返されるパターン
m = re.match("(abc)+", "abcabca")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 6), match='abcabc'>
```

解説：
- `( )` はパターンをグループ化します
- この例では "abc" という3文字グループが繰り返し出現するパターンにマッチしました
- 結果として "abcabc" （2回の繰り返し）がマッチしました

### その他の特殊文字

#### \s - 空白文字

以下のコードを入力して実行してみましょう：

```python
# 空白文字にマッチするパターン
m = re.match(r"\s", " ")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match=' '>
```

解説：
- `\s` はスペース、タブ、改行などの空白文字にマッチします

#### \ - エスケープ文字

以下のコードを入力して実行してみましょう：

```python
# アスタリスク文字そのものにマッチするパターン
m = re.match(r"\*", "*")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 1), match='*'>
```

解説：
- `\` はその後の特殊文字をエスケープし、文字そのものとして扱います
- この例では `*` は通常特殊な意味を持ちますが、`\*` で「*」という文字自体にマッチします

### アンカー

#### ^ - 行頭

以下のコードを入力して実行してみましょう：

```python
# 行頭に「abc」があるパターン
m = re.search("^abc", "abc test")
print(m)
```

実行結果：
```
<re.Match object; span=(0, 3), match='abc'>
```

解説：
- `^` は文字列の先頭を表すアンカーです
- この例では文字列が "abc" で始まるためマッチしました

#### $ - 行末

以下のコードを入力して実行してみましょう：

```python
# 行末に「abc」があるパターン
m = re.search("abc$", "test abc")
print(m)
```

実行結果：
```
<re.Match object; span=(5, 8), match='abc'>
```

解説：
- `$` は文字列の末尾を表すアンカーです
- この例では文字列が "abc" で終わるためマッチしました
