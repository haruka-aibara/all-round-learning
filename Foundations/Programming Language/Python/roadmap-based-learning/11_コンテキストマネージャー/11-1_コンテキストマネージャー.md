# Pythonコンテキストマネージャー

## 概要
コンテキストマネージャーはリソースの確保と解放を自動的に管理する仕組みで、Pythonでの安全なリソース管理に不可欠です。

## 主要概念
コンテキストマネージャーは`with`文で使用され、ブロック終了時に自動的にリソースのクリーンアップを行います。

## 実践例

### 例1: ファイル操作でのコンテキストマネージャー

ファイル操作は、コンテキストマネージャーの最も一般的な使用例です。

```python
# このコードを入力して実行してみましょう
with open('sample.txt', 'w') as file:
    file.write('こんにちは、コンテキストマネージャー！')

# withブロックを抜けると、ファイルは自動的にクローズされます
```

**実行方法**: 上記のコードをPythonスクリプトとして保存し実行します。

**期待される出力**: 実行結果は表示されませんが、`sample.txt`というファイルが作成され、内容に「こんにちは、コンテキストマネージャー！」と書き込まれています。

**解説**: 
- `with open(...) as file:` でファイルを開き、変数`file`にファイルオブジェクトを割り当てます
- `withブロック`内でファイル操作を行います
- ブロックが終了すると、`file.close()`が自動的に呼び出されます
- エラーが発生した場合でも、確実にファイルがクローズされます

### 例2: コンテキストマネージャーの確認

コンテキストマネージャーがファイルを自動的にクローズしていることを確認してみましょう。

```python
# このコードを入力して実行してみましょう
# ファイルをコンテキストマネージャーで開く
with open('sample.txt', 'r') as file:
    content = file.read()
    print(f"ファイルの内容: {content}")
    print(f"ファイルは閉じられていますか？: {file.closed}")  # ブロック内ではまだ開いている

# withブロックを抜けた後
print(f"ブロックを抜けた後、ファイルは閉じられていますか？: {file.closed}")  # 自動的に閉じられている
```

**実行方法**: 上記のコードをPythonスクリプトとして保存し実行します。

**期待される出力**:
```
ファイルの内容: こんにちは、コンテキストマネージャー！
ファイルは閉じられていますか？: False
ブロックを抜けた後、ファイルは閉じられていますか？: True
```

**解説**:
- `withブロック`内ではファイルはまだ開いているため、`file.closed`は`False`を返します
- ブロックを抜けると自動的にファイルがクローズされ、`file.closed`は`True`になります

### 例3: 自作のコンテキストマネージャー

クラスを使って独自のコンテキストマネージャーを作成することもできます。

```python
# このコードを入力して実行してみましょう
class MyContextManager:
    def __init__(self, name):
        self.name = name
    
    def __enter__(self):
        print(f"{self.name}を開始します")
        return self  # このオブジェクトがasの後の変数に代入されます
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f"{self.name}を終了します")
        # 例外情報を受け取ることができます
        if exc_type:
            print(f"例外が発生しました: {exc_val}")
        return False  # 例外を再送出する場合はFalse、抑制する場合はTrue

# コンテキストマネージャーを使ってみましょう
with MyContextManager("処理A") as cm:
    print("処理Aの内部で何か実行しています")
    print(f"コンテキストマネージャーの名前: {cm.name}")

print("\n例外が発生するケース:")
try:
    with MyContextManager("処理B") as cm:
        print("処理Bで例外を発生させます")
        raise ValueError("これは意図的なエラーです")
except ValueError as e:
    print(f"例外をキャッチしました: {e}")
```

**実行方法**: 上記のコードをPythonスクリプトとして保存し実行します。

**期待される出力**:
```
処理Aを開始します
処理Aの内部で何か実行しています
コンテキストマネージャーの名前: 処理A
処理Aを終了します

例外が発生するケース:
処理Bを開始します
処理Bで例外を発生させます
処理Bを終了します
例外が発生しました: これは意図的なエラーです
例外をキャッチしました: これは意図的なエラーです
```

**解説**:
- コンテキストマネージャーは`__enter__`と`__exit__`メソッドを実装することで作成できます
- `__enter__`メソッドはブロック開始時に呼ばれ、戻り値が`as`の後の変数に代入されます
- `__exit__`メソッドはブロック終了時に呼ばれ、例外情報が渡されます
- `__exit__`の戻り値が`True`の場合、例外は抑制されます
- `__exit__`の戻り値が`False`の場合、例外は再送出されます

### 例4: contextlibを使った簡易コンテキストマネージャー

デコレータを使って簡単にコンテキストマネージャーを作成することもできます。

```python
# このコードを入力して実行してみましょう
from contextlib import contextmanager

@contextmanager
def managed_resource(name):
    print(f"{name}を開きます")
    try:
        # ここでyieldした値がasの後の変数に代入されます
        yield f"{name}のリソース"
    finally:
        # 例外が発生しても必ず実行されます
        print(f"{name}を閉じます")

# 使い方
with managed_resource("データベース") as resource:
    print(f"リソースを使用中: {resource}")
    # 例外が発生しても、finallyブロックは実行されます
    # raise ValueError("エラーテスト")
```

**実行方法**: 上記のコードをPythonスクリプトとして保存し実行します。

**期待される出力**:
```
データベースを開きます
リソースを使用中: データベースのリソース
データベースを閉じます
```

**解説**:
- `contextlib.contextmanager`デコレータを使うと、ジェネレータ関数でコンテキストマネージャーを簡単に実装できます
- `yield`文の前がコンテキストの設定（`__enter__`に相当）
- `yield`文の後がコンテキストの終了処理（`__exit__`に相当）
- `try-finally`を使うことで、例外が発生しても確実にリソースを解放できます

## まとめ

コンテキストマネージャーのメリット:
1. リソースの自動クリーンアップ
2. 例外があっても確実にリソースを解放
3. コードの可読性向上
4. 繰り返しの前処理・後処理をシンプルに記述

Pythonでは「with」文を使ったリソース管理が推奨されています。特にファイル操作、データベース接続、ロック操作などで活用されます。
