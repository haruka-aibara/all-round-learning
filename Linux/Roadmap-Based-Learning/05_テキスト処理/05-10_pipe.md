# 【Linux講座】パイプ

## 概要
Linuxのパイプ（|）は複数のコマンドを連結してデータを渡す強力な機能で、テキスト処理の効率を飛躍的に向上させます。

## 主要概念
パイプはあるコマンドの標準出力（stdout）を別のコマンドの標準入力（stdin）に直接渡す仕組みで、中間ファイルを作成せずに複雑なデータ処理ができます。

## 実践コマンド例

### 1. 基本的なパイプの使い方

```bash
ls -l | grep ".txt"
```

このコマンドを入力して実行してみましょう。出力例：

```
-rw-r--r-- 1 user group 123 Apr 20 10:30 document.txt
-rw-r--r-- 1 user group 456 Apr 21 14:45 notes.txt
```

**解説**: このコマンドは2つの部分から成り立っています。`ls -l`はディレクトリ内のファイルを詳細表示し、その出力を`|`（パイプ）を通じて`grep ".txt"`に渡します。`grep`は受け取ったテキストから".txt"を含む行だけを抽出します。結果として、テキストファイル（.txt）だけが表示されます。

### 2. 複数のパイプを繋げる

```bash
cat /etc/passwd | grep "bash" | sort
```

このコマンドを入力して実行してみましょう。出力例：

```
root:x:0:0:root:/root:/bin/bash
user1:x:1000:1000:User One:/home/user1:/bin/bash
user2:x:1001:1001:User Two:/home/user2:/bin/bash
```

**解説**: このコマンドでは、`cat /etc/passwd`でパスワードファイルの内容を表示し、`grep "bash"`でbashシェルを使用しているユーザーの行だけを抽出し、最後に`sort`コマンドでアルファベット順に並べ替えています。3つのコマンドがパイプで連結されています。

### 3. カウント処理を含むパイプ

```bash
ls -l | wc -l
```

このコマンドを入力して実行してみましょう。出力例：

```
15
```

**解説**: このコマンドは、`ls -l`の出力（カレントディレクトリのファイル一覧）を`wc -l`（行数をカウント）に渡しています。結果として、ディレクトリ内のファイル数（および最初の合計行）が表示されます。

### 4. テキスト処理の組み合わせ

```bash
cat /etc/passwd | grep -v "nologin" | cut -d: -f1,6 | sort
```

このコマンドを入力して実行してみましょう。出力例：

```
root:/root
user1:/home/user1
user2:/home/user2
```

**解説**: このコマンドは複数の処理を組み合わせています：
1. `cat /etc/passwd` - パスワードファイルの内容を表示
2. `grep -v "nologin"` - "nologin"を含まない行だけを抽出（実際にログインできるアカウント）
3. `cut -d: -f1,6` - コロン（:）で区切られたフィールドのうち、1番目（ユーザー名）と6番目（ホームディレクトリ）だけを抽出
4. `sort` - 結果をアルファベット順に並べ替え

### 5. パイプとリダイレクトの組み合わせ

```bash
ls -l | grep ".txt" > text_files.txt
```

このコマンドを入力して実行してみましょう。特に出力はありませんが、text_files.txtファイルが作成されます。

```bash
cat text_files.txt
```

このコマンドを入力して実行してみましょう。出力例：

```
-rw-r--r-- 1 user group 123 Apr 20 10:30 document.txt
-rw-r--r-- 1 user group 456 Apr 21 14:45 notes.txt
```

**解説**: このコマンドでは、`ls -l | grep ".txt"`の出力を画面に表示する代わりに、`>`（リダイレクト）を使って`text_files.txt`というファイルに保存しています。パイプとリダイレクトを組み合わせることで、処理結果をファイルに保存できます。

### 6. より複雑なパイプライン処理

```bash
ps aux | grep "firefox" | grep -v "grep" | awk '{print $2}'
```

このコマンドを入力して実行してみましょう。出力例（Firefoxが実行中の場合）：

```
1234
```

**解説**: このコマンドは以下の処理を行っています：
1. `ps aux` - 実行中のすべてのプロセスを表示
2. `grep "firefox"` - "firefox"を含む行（Firefoxプロセス）を抽出
3. `grep -v "grep"` - "grep"を含む行を除外（grepコマンド自体がプロセス一覧に表示されるため）
4. `awk '{print $2}'` - 2番目のフィールド（プロセスID）のみを抽出

結果として、FirefoxのプロセスIDだけが表示されます。

### 7. teeコマンドを使ったパイプ処理

```bash
ls -l | tee file_list.txt | grep ".txt"
```

このコマンドを入力して実行してみましょう。出力例：

```
-rw-r--r-- 1 user group 123 Apr 20 10:30 document.txt
-rw-r--r-- 1 user group 456 Apr 21 14:45 notes.txt
```

**解説**: `tee`コマンドはパイプラインの途中で出力を分岐させます：
1. `ls -l`の出力を`tee file_list.txt`に渡す
2. `tee`は受け取ったデータを`file_list.txt`に保存しつつ、標準出力にも出力する
3. その出力がさらに`grep ".txt"`に渡される

この結果、`ls -l`の全出力が`file_list.txt`に保存され、同時に`.txt`ファイルだけが画面に表示されます。
