# Git マージ入門: Fast-Forward と Non-Fast-Forward

## これだけ覚えよう！
ブランチをマージするとき、Git では「履歴をどう残すか」によって2種類のマージ方法があります：
- **Fast-Forward**：歴史を直線にする（新しいコミットを作らない）
- **Non-Fast-Forward**：枝分かれした歴史を残す（新しいマージコミットを作る）

## Fast-Forward マージ：「巻き戻しなしで早送り」

### 例えるなら...
📼 ビデオテープを早送りするように、ブランチのポインタを単純に進めるだけ

### いつ起こる？
メインブランチが機能ブランチの「親」のままで、自分自身には何も新しい変更がない場合

### 絵で見るとこんな感じ
```
【マージ前】
A---B---C  main
         \
          D---E  feature

【マージ後】
A---B---C---D---E  main
```

### コマンド
```bash
git checkout main
git merge feature
```

### メリット
- 履歴がシンプルでわかりやすい直線になる
- 余分なコミットが作られない

### 使うべき場面
- 個人開発や小さなチーム
- シンプルさを重視する場合
- 短期的な修正作業

## Non-Fast-Forward マージ：「枝の合流点を記録」

### 例えるなら...
🌳 木の枝が合流する場所に「ここで合流したよ」と目印を付ける

### いつ起こる？
- メインブランチと機能ブランチの両方に独自の変更がある場合
- または `--no-ff` オプションを使って強制的に作る場合

### マージコミットとは？
- **マージコミット（図のG）** は、2つのブランチの変更内容を統合した新しいコミット
- 特別な性質：2つの親（FとE）を持つ唯一のコミット
- 内容：両方のブランチの変更が全て含まれている

### 絵で見るとこんな感じ
```
【マージ前】
A---B---C---F  main
    \
     D---E  feature

【マージ後】
A---B---C---F---G  main  (Gがマージコミット)
    \         /
     D-------E  feature
```

### 具体例で理解する
1. mainブランチ：ログイン機能を作成（コミットF）
2. featureブランチ：新しいボタンを追加（コミットDとE）
3. マージ後のG：ログイン機能も新しいボタンも両方含まれる状態

### コマンド
```bash
git checkout main
git merge --no-ff feature  # 強制的にマージコミットを作る
```

### メリット
- 「どの機能をいつマージしたか」が履歴に残る
- ブランチの開発が視覚的に明確になる
- 必要なら機能全体を簡単に元に戻せる

### 使うべき場面
- チーム開発
- 「どの機能がいつ追加されたか」を明確にしたい場合
- リリース管理が重要なプロジェクト

## 実践的なアドバイス

### どっちを使えばいい？
- 個人やシンプルなプロジェクト → Fast-Forward
- 大きなチームや複雑なプロジェクト → Non-Fast-Forward

### チームでの設定方法
```bash
# プロジェクト全体で常にマージコミットを作る設定
git config --global merge.ff false
```

### 覚えておくコツ
「Fast-Forward = 直線、Non-FF = 枝分かれの記録」
